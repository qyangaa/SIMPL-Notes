# Problem 1. *Address generation.

\* The following C code fragment transposes array A into array B.

```c
#define M 40
#define N 50
void transpose(short A[M][N], B[N][M]) {
  for (int i = 0; i < M; i++) // 40
    for (int j = 0; i < N; j++) // 50
      B[j][i] = A[i][j];
 }
```



(a)  code for the assignment statement `B[j][i] = A[i][j]`;

```assembly
[%rdi: A, %rsi: B, %r8d: i, %r9d: j]
Calculation:
[i][j] = A + 2*(i*50 + j)
[j][i] = B + 2*(j*40 + i)


Code:
LEAQ (%r8, %r8, 2), %r10 # 3i in %r10
LEAQ (%r8,%r10, 8), %r10 # 25i in %r10
LEAQ (%r9, %r10, 2), %r10 # 50i+j in %r10
MOVW (%rdi, %r10, 2), %r11 # A[i][j] in %r11
LEAQ (%r9, %r9, 4), %r10 # 5j in %r10
LEAQ (%r8, %r9, 8), %r10 # 40j+i in %r10
MOVW %r11, (%rsi, %r10, 2) # %r11 moved to B[j][i]
```



(b)  Simplify the generated code by exploiting regularities in the sequence of accesses to arrays A and B. Use additional registers if needed.



```assembly
[%rdi: A, %rsi: B, %r8d: i, %r9d: j, %r10: i*50 + j from last loop, %r11: j*40 + i from last loop]

MOVQ, (%rdi, %rax), %rax //  A[i][j] to %rax
MOVQ, %rax, (%rsi, rbx) // %rax to B[j][i]

for incrementing j or i:
LEAQ 1(%r11 or %r10) %r10 or %r11
LEAQ 80 or 100(%r11 or %r10) %r10 or %r11
```





# Problem 2. *Code generation.

\* The following C code counts the number of 1-bits in the variable x. Hand-translate it into x86-64 assembly language code. The input parameter x is provided to you in register %rdi, and the result needs to be returned in register %rax.

```c
int pop(unsigned x) {
  x = (x & 0x55555555) + ((x >> 1) & 0x55555555);
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  x = (x + (x >> 4)) & 0x0F0F0F0F;
  x += x >> 8;
  x += x >> 16;
  return x & 0x0000003F;
}
```

Also, it might be instructive to examine the assembly code that gcc generates for these code fragments, and see whether it looks anything like the assembly code you generated by hand.

```assembly
[%rdi: x, %rax: result]

// x = (x & 0x55555555) + ((x >> 1) & 0x55555555);
MOVl %edi, %eax [Q: why use movl and e.. here rather than movq?]
ANDl $0x55555555, %eax
SHRl 1, %ebx
ANDl %0x55555555, %ebx
ADDl %ebx, %eax

        movl    -4(%rbp), %eax
        andl    $1431655765, %eax
        movl    %eax, %edx
        movl    -4(%rbp), %eax
        shrl    %eax
        andl    $1431655765, %eax
        addl    %edx, %eax
        movl    %eax, -4(%rbp)

// x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
MOVl %edi, %eax
ANDl $0x33333333, %eax
SHRl 2, %ebx
ANDl %0x33333333, %ebx
ADDl %ebx, %eax

				movl    -4(%rbp), %eax
        andl    $858993459, %eax
        movl    %eax, %edx
        movl    -4(%rbp), %eax
        shrl    $2, %eax
        andl    $858993459, %eax
        addl    %edx, %eax
        movl    %eax, -4(%rbp)

// x = (x + (x >> 4)) & 0x0F0F0F0F;
MOVQ %rax, %rbx
SARQ 4, %rbx
ADDQ %rax %rbx
ANDQ $0x0F0F0F0F, %rbx
ADDQ %rbx, %rax

        movl    -4(%rbp), %eax
        shrl    $4, %eax
        movl    %eax, %edx
        movl    -4(%rbp), %eax
        addl    %edx, %eax
        andl    $252645135, %eax
        movl    %eax, -4(%rbp)

// x += x >> 8;
MOVQ %rax, %rbx
SARQ 8, %rbx
ADDQ %rbx, %rax

        movl    -4(%rbp), %eax
        shrl    $8, %eax
        addl    %eax, -4(%rbp)

// x += x >> 16;
MOVQ %rax, %rbx
SARQ 16, %rbx
ADDQ %rbx, %rax

        movl    -4(%rbp), %eax
        shrl    $16, %eax
        addl    %eax, -4(%rbp)

// x & 0x0000003F
ANDQ $0x0F0F0F0F, %rax

        movl    -4(%rbp), %eax
        andl    $63, %eax
```





# Problem 3. *Reverse-engineering stack frames.

\* The assembly code generated by gcc for a C function with the prototype long bar(long); is as follows.

```assembly
bar: (factorial)
# prologue
pushq %rbp # callee saved register -- 4 (word)
movq %rsp, %rbp # link
subq $32, %rsp # 0-8: old rbp, 8-32: 3 local vars

# body
movq %rdi, -8(%rbp) # caller saved
cmpq $1, -8(%rbp) # cmpq: set flag based on src1 and src2
jg LBB0_2 # jump if 1 > var1
movq $1, -16(%rbp) # var1 = 1
jmp LBB0_3
LBB0_2:
movq -8(%rbp), %rax # rax = var1
movq -8(%rbp), %rcx # rcx = var1
subq $1, %rcx # rcx = rcx - 1

# pre call
movq %rcx, %rdi # param1 = rcx, prepare param for call
movq %rax, -24(%rbp) # var2 = rax, store rax value

# call
callq bar # recursive call to bar, push 8 bytes for return address

# post call
movq -24(%rbp), %rcx # rcx = var2, restore return vlaue
imulq %rax, %rcx # rcx = rcx * rax
movq %rcx, -16(%rbp) # var1 = rcx

LBB0_3:
# epilogue
movq -16(%rbp), %rax # rax = var2, store return value
addq $32, %rsp # clear local var on stack 
popq %rbp # pop fbr

# return
retq
```

(a)  Show the layout of the stack frame for this function. Indicate each of the four areas of the stack frame, how much each area takes, and the total size of the stack frame.

```
old rbp --4
var1 -- 8
old rax -- 8
ret addr -- 8
[tot 32]
```



(b)  The function is invoked with an argument value of 2. Show the state of the stack just before program execution reaches the recursive call to bar.

```assembly
bar:
# prologue
pushq %rbp 
movq %rsp, %rbp 
subq $32, %rsp 

# body
movq %rdi, -8(%rbp) # var1 = param1 = 2
cmpq $1, -8(%rbp) 
jg LBB0_2 # jump if 1 > var1 =2
movq $1, -16(%rbp)
jmp LBB0_3
LBB0_2:
movq -8(%rbp), %rax # rax = var1 = 2
movq -8(%rbp), %rcx # rcx = var1 = 2
subq $1, %rcx # rcx = rcx - 1 = 1

# pre call
movq %rcx, %rdi # param1 = rcx = 1
movq %rax, -24(%rbp) # var3 = rax = 2

rbp: old
var1: 2
var2: 
ret: 2
```



(c)  Show the state of the stack when the function is in the recursive call to bar.

```assembly
bar:
# prologue
pushq %rbp # new
movq %rsp, %rbp 
subq $32, %rsp 

# body
movq %rdi, -8(%rbp) # var1 = param1 = 1
cmpq $1, -8(%rbp) 
jg LBB0_2 # jump if 1 > var1 =1
movq $1, -16(%rbp) # var2 = 1
jmp LBB0_3

rbp: new
var1: 1
var2: 1
var3: 1
```



(d)  What value does the function return when invoked with an argument value of 2?

when invoked with 1, return 1:

```assembly
bar:
# prologue
pushq %rbp 
movq %rsp, %rbp 
subq $32, %rsp 

# body
movq %rdi, -8(%rbp) # var1 = param1 = 1
cmpq $1, -8(%rbp) 
jg LBB0_2 # jump if 1 > var1 =1
movq $1, -16(%rbp) # var2 = 1
jmp LBB0_3

LBB0_3:
# epilogue
movq -16(%rbp), %rax # rax = var2 = 1, store return value
addq $32, %rsp # clear local var on stack 
popq %rbp # pop fbr

# return
retq # return 1
```



continue on 2, return 2:

```assembly
rax: 1
var1: 2
var2: 
var3: 2

# call
callq bar // recursive call to bar

# post call
movq -24(%rbp), %rcx # rcx = var3 = 1
imulq %rax, %rcx # rcx = rcx * rax = 2
movq %rcx, -16(%rbp) # var2 = rcx = 2

LBB0_3:
# epilogue
movq -16(%rbp), %rax # rax = var2 = 2
addq $32, %rsp # clear local var on stack 
popq %rbp # pop fbr

# return
retq # return 2
```



# Problem 4. *Caller-saved and callee-saved registers.

\* For each of the C procedures below, identify the minimal sets of caller-saved and callee-saved registers that will be saved/restored in the assembly code generated for the procedure. The normal x86-64 procedure call/return linkage conventions are followed, and each procedure is compiled separately.

```c
unsigned long fn1(long x, long y){
	return x*x + y*y;
}

caller-saved:
0, //leaf procedure

callee-saved:
0, // leaf procedure, can reuse registers of x and y for computation, no local variables so no need to change rbx [Q: callee only need to save rbx if there are local variables?]
```



```c
unsigned long fn2(long x, long y){
	return fn1(x+y, y-2);
}

caller-saved:
0, //not using values after function call, return rax immediately

callee-saved:
0, // registers can be overwritten in place, no local variables so no need to change rbx
```



```c
unsigned long fn3(long x, long y){
	return fn1(x, y) - x*y;
}

caller-saved:
%rdi, %rsi, //parameter needed after call to fn1

callee-saved:
0, // registers can be overwritten in place, no local variables so no need to change rbx
```



```c
unsigned long fn4(long x, long y){
  y = fn1(y, x);
	return fn2(x,y);
}

caller-saved:
%rdi, //parameter needed after call to fn2

callee-saved:
0, // registers can be overwritten in place, no local variables so no need to change rbx


```



```c
unsigned long fn5(long x, long y){
	return fn1(x,y) + fn2(x,y);
}

caller-saved:
%rdi, %rsi // x,y used after call to fn1
%rax // return value of fn1 need to be saved for usage later

callee-saved:
0, // no local variables so no need to change rbx
```





